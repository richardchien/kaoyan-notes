# 堆

- 是优先队列接口的实现，循优先级访问
- 维护偏序而不是全序关系
- 最大（小）堆：除了堆顶之外，每个节点都不大（小）于其父节点——堆序性
- 基本操作：`insert(e)`、`getMax()`、`delMax()`

## 二叉堆

- 实现为完全二叉树
- 使用向量存储
- 高度 $O(\log n)$

由于完全二叉树的性质，有：

- 若 v 有左孩子，则 $idx(lchild(v)) = 2 \times idx(v) + 1$
- 若 v 有右孩子，则 $idx(rchild(v)) = 2 \times idx(v) + 2$
- 若 v 有父节点，则 $idx(parent(v)) = \lfloor (idx(v) - 1) / 2 \rfloor = \lceil (idx(v) / 2) \rceil - 1$

### 插入

- 将新元素插入到向量末尾，然后进行上滤——不断比较与父节点的大小并按需交换，直到恢复堆序性
- 上滤过程累计不超过树高，故插入操作复杂度为 $O(\log n)$
- 在元素大小随机分布的情况下，新元素平均需要提升的高度非常低（因为完全二叉树的大部分元素在较低层）
- 上滤过程中，与父节点交换时无需完整进行三次赋值，只需要用父节点的值覆盖当前节点（当前节点的值保存在局部变量，不会丢失）

### 删除

- 将最末尾的元素覆盖到堆顶，然后进行下滤——不断比较与较大孩子的大小并按需交换，直到恢复堆序性
- 下滤过程累计不超过树高，故删除操作复杂度为 $O(\log n)$

### 建堆

#### 蛮力算法

对所有元素依次调用插入操作，复杂度为 $O(\log 1 + \log 2 + \cdots + \log n) = O(\log {n!}) = O(n \log n)$。

问题在于时间复杂度足以实现全排序，但最终却只得到一个偏序。

#### 自上而下的上滤

将输入元素组织成向量后，首元素可视为规模为 1 的堆，然后从左向右依次上滤。复杂度同蛮力算法，为 $\sum\limits_{i=0}^h (i \cdot 2^i) = O(n \log n)$。

#### Floyd 算法——自下而上的下滤

将输入元素组织成向量后，可直接视为完全二叉树，此时各叶节点自成一个堆，然后自下而上、从右向左，依次对内部节点进行下滤，使其进入两个孩子合并成的更大堆中。

![](media/15688574627705.jpg)

复杂度为 $\sum\limits_{i=0}^h ((h-i) \cdot 2^i) = O(n)$。

优化的根源在于，完全二叉树中低层节点**远多于**高层节点，Floyd 建堆算法减少了低层节点的调整次数，增加了高层节点的调整次数。

## 应用

### Huffman 编码树

使用堆结构来维护 Huffman 森林，可使每次取权值最小的树的复杂度为 $O(\log n)$，于是构造 Huffman 编码树总的复杂度为 $O(n \log n)$。

### 堆排序

见“排序”单独章节。
